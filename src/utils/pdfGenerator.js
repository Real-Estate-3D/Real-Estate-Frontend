import { jsPDF } from 'jspdf';
import * as Cesium from 'cesium';
import { fetchGeoServerLayers } from './geoServerLayerManager.js';
import { GEOSERVER_CONFIG } from './runtimeConfig.js';

/**
 * Utility functions for generating PDF reports from parcel data and map screenshots
 */
const PDF_THEME = {
  // Modern professional color palette
  primary: [16, 185, 129],        // Emerald green
  primaryDark: [5, 150, 105],     // Dark emerald
  primaryLight: [209, 250, 229],   // Light emerald
  accent: [59, 130, 246],         // Bright blue
  accentDark: [29, 78, 216],      // Dark blue
  accentLight: [219, 234, 254],   // Light blue
  dark: [31, 41, 55],             // Dark gray
  darkMuted: [75, 85, 99],        // Muted gray
  muted: [107, 114, 128],         // Medium gray
  light: [249, 250, 251],         // Off white
  border: [229, 231, 235],        // Light border
  borderDark: [209, 213, 219],    // Medium border
  tableHeader: [240, 253, 244],   // Light green header
  tableStripe: [249, 250, 251],   // Subtle stripe
  success: [34, 197, 94],         // Green
  warning: [251, 146, 60],        // Orange
  error: [239, 68, 68],           // Red
  white: [255, 255, 255],         // Pure white
  shadow: [0, 0, 0, 0.1],         // Subtle shadow
};

/**
 * Draw a card-style container with shadow effect
 */
const drawCard = (pdf, x, y, width, height, fillColor = PDF_THEME.white, borderColor = PDF_THEME.border) => {
  // Shadow effect (multiple layers for depth)
  pdf.setFillColor(0, 0, 0);
  pdf.setGState(new pdf.GState({ opacity: 0.05 }));
  pdf.roundedRect(x + 1, y + 1, width, height, 2, 2, 'F');
  pdf.setGState(new pdf.GState({ opacity: 1 }));

  // Main card background
  pdf.setFillColor(...fillColor);
  pdf.setDrawColor(...borderColor);
  pdf.setLineWidth(0.3);
  pdf.roundedRect(x, y, width, height, 2, 2, 'FD');
};

/**
 * Draw a decorative section header
 */
const drawSectionHeader = (pdf, text, x, y, width, options = {}) => {
  const {
    fontSize = 13,
    color = PDF_THEME.primaryDark,
    withBackground = true,
    withIcon = true,
  } = options;

  const height = 12;

  if (withBackground) {
    // Gradient-like effect with two rectangles
    pdf.setFillColor(...PDF_THEME.primaryLight);
    pdf.roundedRect(x, y - 8, width, height, 1.5, 1.5, 'F');

    // Accent bar on left
    pdf.setFillColor(...PDF_THEME.primary);
    pdf.roundedRect(x, y - 8, 3, height, 1.5, 1.5, 'F');
  }

  // Section title
  pdf.setFontSize(fontSize);
  pdf.setFont(undefined, 'bold');
  pdf.setTextColor(...color);

  if (withIcon) {
    // Simple decorative circle
    pdf.setFillColor(...PDF_THEME.accent);
    pdf.circle(x + 8, y - 3, 1.5, 'F');
    pdf.text(text, x + 12, y);
  } else {
    pdf.text(text, x + 5, y);
  }

  pdf.setTextColor(0, 0, 0);
  pdf.setFont(undefined, 'normal');
};

/**
 * Draw a badge/label
 */
const drawBadge = (pdf, text, x, y, color = PDF_THEME.primary) => {
  pdf.setFontSize(8);
  pdf.setFont(undefined, 'bold');
  const textWidth = pdf.getTextWidth(text);
  const padding = 2;

  // Badge background
  pdf.setFillColor(...color);
  pdf.roundedRect(x, y - 3, textWidth + padding * 2, 5, 1, 1, 'F');

  // Badge text
  pdf.setTextColor(255, 255, 255);
  pdf.text(text, x + padding, y);
  pdf.setTextColor(0, 0, 0);
  pdf.setFont(undefined, 'normal');

  return textWidth + padding * 2 + 2;
};

/**
 * Draw page header
 */
const drawPageHeader = (pdf, pageNumber, totalPages, title) => {
  const pageWidth = pdf.internal.pageSize.getWidth();
  const margin = 20;

  // Header background
  pdf.setFillColor(...PDF_THEME.light);
  pdf.rect(0, 0, pageWidth, 15, 'F');

  // Top accent line
  pdf.setDrawColor(...PDF_THEME.primary);
  pdf.setLineWidth(1.5);
  pdf.line(0, 0, pageWidth, 0);

  // Title
  pdf.setFontSize(8);
  pdf.setFont(undefined, 'normal');
  pdf.setTextColor(...PDF_THEME.darkMuted);
  pdf.text(title, margin, 10);

  // Page number
  pdf.text(`Page ${pageNumber}`, pageWidth - margin - 15, 10);

  pdf.setTextColor(0, 0, 0);
};

/**
 * Draw page footer
 */
const drawPageFooter = (pdf) => {
  const pageHeight = pdf.internal.pageSize.getHeight();
  const pageWidth = pdf.internal.pageSize.getWidth();
  const margin = 20;

  // Footer line
  pdf.setDrawColor(...PDF_THEME.border);
  pdf.setLineWidth(0.5);
  pdf.line(margin, pageHeight - 15, pageWidth - margin, pageHeight - 15);

  // Footer text
  pdf.setFontSize(7);
  pdf.setFont(undefined, 'italic');
  pdf.setTextColor(...PDF_THEME.muted);
  const footerText = 'Generated by Real Estate 3D Platform';
  const textWidth = pdf.getTextWidth(footerText);
  pdf.text(footerText, (pageWidth - textWidth) / 2, pageHeight - 10);

  pdf.setTextColor(0, 0, 0);
  pdf.setFont(undefined, 'normal');
};

/**
 * Calculate centroid of a feature geometry
 * @param {Object} feature - The feature object with geometry
 * @returns {Object|null} - Centroid coordinates {lat, lon} or null
 */
const calculateCentroid = (feature) => {
  if (!feature || !feature.geometry) {
    return null;
  }

  const geometry = feature.geometry;
  let coordinates = [];

  if (geometry.type === 'Polygon' && geometry.coordinates && geometry.coordinates[0]) {
    coordinates = geometry.coordinates[0];
  } else if (geometry.type === 'MultiPolygon' && geometry.coordinates && geometry.coordinates[0] && geometry.coordinates[0][0]) {
    coordinates = geometry.coordinates[0][0];
  }

  if (coordinates.length === 0) {
    return null;
  }

  // Calculate centroid
  let sumX = 0, sumY = 0;
  for (let i = 0; i < coordinates.length; i++) {
    sumX += coordinates[i][0];
    sumY += coordinates[i][1];
  }
  
  return {
    lon: sumX / coordinates.length,
    lat: sumY / coordinates.length
  };
};

/**
 * Format centroid for display
 * @param {Object} centroid - Centroid object with lat/lon
 * @returns {string} - Formatted centroid string
 */
const formatCentroid = (centroid) => {
  if (!centroid || typeof centroid.lat !== 'number' || typeof centroid.lon !== 'number') {
    return 'N/A';
  }
  
  return `${centroid.lat.toFixed(6)}, ${centroid.lon.toFixed(6)}`;
};

/**
 * Format field names by removing underscores and capitalizing first letters
 * @param {string} fieldName - The field name to format
 * @returns {string} - The formatted field name
 */
const formatFieldName = (fieldName) => {
  return fieldName
    .replace(/_/g, ' ')
    .split(' ')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join(' ');
};

/**
 * Format field values for better display
 * @param {any} value - The field value to format
 * @param {string} fieldName - The field name for context
 * @returns {string} - The formatted value
 */
const formatFieldValue = (value, fieldName) => {
  if (value === null || value === undefined || value === '') {
    return 'N/A';
  }

  if (typeof value === 'object') {
    if (value instanceof Date) {
      return value.toLocaleDateString('en-CA');
    }

    if (Array.isArray(value)) {
      if (value.length === 0) return 'N/A';
      if (value.every((item) => typeof item === 'number')) {
        const items = value.slice(0, 6).map((num) => num.toFixed(6));
        return value.length > 6 ? `${items.join(', ')} ...` : items.join(', ');
      }
      const serialized = JSON.stringify(value);
      return serialized.length > 180 ? `${serialized.slice(0, 177)}...` : serialized;
    }

    const lat = value.lat ?? value.latitude ?? value.y;
    const lon = value.lon ?? value.lng ?? value.longitude ?? value.x;
    if (typeof lat === 'number' && typeof lon === 'number') {
      return `${lat.toFixed(6)}, ${lon.toFixed(6)}`;
    }

    const serialized = JSON.stringify(value);
    return serialized.length > 180 ? `${serialized.slice(0, 177)}...` : serialized;
  }

  // Handle dates
  if (fieldName && (fieldName.toLowerCase().includes('date') || fieldName.toLowerCase().includes('time'))) {
    try {
      const date = new Date(value);
      if (!isNaN(date.getTime())) {
        return date.toLocaleDateString('en-CA'); // YYYY-MM-DD format
      }
    } catch (e) {
      // Not a date, continue with regular formatting
    }
  }

  // Handle coordinates
  if (fieldName && (fieldName.toLowerCase().includes('lat') || fieldName.toLowerCase().includes('lon') || 
                   fieldName.toLowerCase().includes('x') || fieldName.toLowerCase().includes('y'))) {
    const num = parseFloat(value);
    if (!isNaN(num)) {
      return num.toFixed(6);
    }
  }

  // Handle numbers
  const num = parseFloat(value);
  if (!isNaN(num) && isFinite(num)) {
    // If it's an integer, don't show decimals
    if (num % 1 === 0) {
      return num.toLocaleString();
    } else {
      return num.toLocaleString(undefined, { maximumFractionDigits: 2 });
    }
  }

  return String(value);
};

const waitForTilesLoaded = (scene, timeoutMs = 5000) => {
  if (!scene?.globe) {
    return Promise.resolve();
  }

  if (scene.globe.tilesLoaded) {
    return Promise.resolve();
  }

  return new Promise((resolve) => {
    let done = false;
    let removeListener = null;

    const finish = () => {
      if (done) return;
      done = true;
      if (removeListener) removeListener();
      resolve();
    };

    const timeoutId = setTimeout(() => {
      finish();
    }, timeoutMs);

    removeListener = scene.globe.tileLoadProgressEvent.addEventListener((remaining) => {
      if (remaining === 0 || scene.globe.tilesLoaded) {
        clearTimeout(timeoutId);
        finish();
      }
    });
  });
};

const getFeatureBounds = (feature) => {
  if (!feature?.geometry?.coordinates) return null;

  const coords = [];
  const collect = (value) => {
    if (!Array.isArray(value)) return;
    if (value.length >= 2 && typeof value[0] === 'number' && typeof value[1] === 'number') {
      coords.push(value);
      return;
    }
    value.forEach(collect);
  };

  collect(feature.geometry.coordinates);

  if (coords.length === 0) return null;

  let minLon = Infinity;
  let minLat = Infinity;
  let maxLon = -Infinity;
  let maxLat = -Infinity;

  coords.forEach(([lon, lat]) => {
    if (lon < minLon) minLon = lon;
    if (lon > maxLon) maxLon = lon;
    if (lat < minLat) minLat = lat;
    if (lat > maxLat) maxLat = lat;
  });

  if (!isFinite(minLon) || !isFinite(minLat) || !isFinite(maxLon) || !isFinite(maxLat)) {
    return null;
  }

  return { minLon, minLat, maxLon, maxLat };
};

const expandBounds = (bounds, paddingRatio = 0.15) => {
  if (!bounds) return null;

  const width = Math.max(bounds.maxLon - bounds.minLon, 0);
  const height = Math.max(bounds.maxLat - bounds.minLat, 0);
  const lonPad = width > 0 ? width * paddingRatio : 0.0005;
  const latPad = height > 0 ? height * paddingRatio : 0.0005;

  return {
    minLon: bounds.minLon - lonPad,
    minLat: bounds.minLat - latPad,
    maxLon: bounds.maxLon + lonPad,
    maxLat: bounds.maxLat + latPad,
  };
};

const setCameraToBounds = (viewer, bounds) => {
  if (!viewer || !bounds) return;
  const rectangle = Cesium.Rectangle.fromDegrees(
    bounds.minLon,
    bounds.minLat,
    bounds.maxLon,
    bounds.maxLat
  );
  viewer.camera.setView({ destination: rectangle });
  viewer.scene.requestRender();
};

const convertGeoJSONToWKT = (geometry) => {
  if (!geometry || !geometry.type || !geometry.coordinates) {
    return null;
  }

  const coordsToWKT = (coords) => coords.map((c) => `${c[0]} ${c[1]}`).join(', ');

  switch (geometry.type) {
    case 'Point':
      return `POINT(${geometry.coordinates[0]} ${geometry.coordinates[1]})`;
    case 'Polygon': {
      const rings = geometry.coordinates
        .map((ring) => `(${coordsToWKT(ring)})`)
        .join(', ');
      return `POLYGON(${rings})`;
    }
    case 'MultiPolygon': {
      const polygons = geometry.coordinates
        .map((polygon) => {
          const rings = polygon.map((ring) => `(${coordsToWKT(ring)})`).join(', ');
          return `(${rings})`;
        })
        .join(', ');
      return `MULTIPOLYGON(${polygons})`;
    }
    default:
      console.warn(`Unsupported geometry type for WKT conversion: ${geometry.type}`);
      return null;
  }
};

const fetchLayerIntersections = async (geometry, layers) => {
  if (!geometry || !layers?.length) return [];

  const geometryWKT = convertGeoJSONToWKT(geometry);
  if (!geometryWKT) return [];

  const queryLayer = async (layerName, geomField = 'geom') => {
    const params = new URLSearchParams({
      service: 'WFS',
      version: '1.1.0',
      request: 'GetFeature',
      typeName: `${GEOSERVER_CONFIG.workspace}:${layerName}`,
      outputFormat: 'application/json',
      srsName: GEOSERVER_CONFIG.srs,
      maxFeatures: '25',
    });
    params.append('CQL_FILTER', `INTERSECTS(${geomField}, ${geometryWKT})`);
    const url = `${GEOSERVER_CONFIG.wfsUrl}?${params.toString()}`;

    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`WFS ${layerName} failed (${response.status})`);
    }
    const data = await response.json();
    return data?.features || [];
  };

  const results = await Promise.all(
    layers.map(async (layer) => {
      try {
        let features = await queryLayer(layer.name, 'geom');
        return { layer, features };
      } catch (error) {
        try {
          const features = await queryLayer(layer.name, 'the_geom');
          return { layer, features };
        } catch (fallbackError) {
          console.warn(`Layer query failed for ${layer.name}:`, fallbackError.message);
          return { layer, features: [], error: fallbackError };
        }
      }
    })
  );

  return results;
};

const pickFeatureLabel = (properties, index) => {
  if (!properties) return `Feature ${index + 1}`;
  const candidates = [
    'name',
    'admin_name',
    'street_name',
    'full_address',
    'address',
    'civic_address',
    'pin',
    'arn',
    'parcel_id',
    'plan_number',
    'roll_number',
    'id',
  ];
  for (const key of candidates) {
    const value = properties[key];
    if (value !== undefined && value !== null && value !== '') {
      return String(value);
    }
  }
  return `Feature ${index + 1}`;
};

const formatFeatureDetails = (properties) => {
  if (!properties) return 'No attributes';
  const keys = Object.keys(properties).filter((key) => !key.startsWith('_'));
  const selected = keys.slice(0, 6);
  if (selected.length === 0) return 'No attributes';
  return selected
    .map((key) => `${formatFieldName(key)}: ${formatFieldValue(properties[key], key)}`)
    .join(', ');
};

const ensureSpace = (pdf, yPosition, requiredHeight, margin) => {
  const pageHeight = pdf.internal.pageSize.getHeight();
  if (yPosition + requiredHeight > pageHeight - margin) {
    pdf.addPage();
    return margin;
  }
  return yPosition;
};

const drawStripedTable = ({
  pdf,
  x,
  y,
  headers,
  rows,
  colWidths,
  margin = 20,
  fontSize = 9,
  headerFontSize = 10,
  rowPadding = 3,
  stripeColor = PDF_THEME.tableStripe,
  headerColor = PDF_THEME.tableHeader,
}) => {
  const lineHeight = fontSize * 0.5 + 3;
  const totalWidth = colWidths.reduce((sum, width) => sum + width, 0);
  const renderHeaders = headers && headers.length > 0;

  let currentY = y;

  // Draw table container with shadow
  pdf.setGState(new pdf.GState({ opacity: 0.08 }));
  pdf.setFillColor(0, 0, 0);
  pdf.roundedRect(x + 1, y + 1, totalWidth, 10, 1.5, 1.5, 'F');
  pdf.setGState(new pdf.GState({ opacity: 1 }));

  const drawHeader = () => {
    if (!renderHeaders) return;
    currentY = ensureSpace(pdf, currentY, headerFontSize + rowPadding * 2 + 2, margin);

    // Header with gradient effect
    pdf.setFillColor(...headerColor);
    pdf.roundedRect(x, currentY, totalWidth, headerFontSize + rowPadding * 2, 1.5, 1.5, 'F');

    // Header border
    pdf.setDrawColor(...PDF_THEME.primary);
    pdf.setLineWidth(0.5);
    pdf.roundedRect(x, currentY, totalWidth, headerFontSize + rowPadding * 2, 1.5, 1.5, 'S');

    pdf.setFontSize(headerFontSize);
    pdf.setFont(undefined, 'bold');
    pdf.setTextColor(...PDF_THEME.primaryDark);
    headers.forEach((header, index) => {
      const colX = x + colWidths.slice(0, index).reduce((sum, w) => sum + w, 0);
      pdf.text(String(header), colX + rowPadding + 1, currentY + headerFontSize + rowPadding - 1);
    });
    pdf.setTextColor(0, 0, 0);
    currentY += headerFontSize + rowPadding * 2;
  };

  drawHeader();

  pdf.setFontSize(fontSize);
  pdf.setFont(undefined, 'normal');

  rows.forEach((row, rowIndex) => {
    const cellLines = row.map((cell, index) => {
      const width = colWidths[index] - rowPadding * 2 - 2;
      return pdf.splitTextToSize(String(cell ?? 'N/A'), width);
    });
    const maxLines = Math.max(...cellLines.map((lines) => lines.length));
    const rowHeight = Math.max(lineHeight * maxLines, lineHeight) + rowPadding * 2;

    const nextY = ensureSpace(pdf, currentY, rowHeight, margin);
    if (nextY !== currentY) {
      currentY = nextY;
      drawHeader();
    }

    // Alternating row colors
    if (rowIndex % 2 === 0) {
      pdf.setFillColor(...stripeColor);
    } else {
      pdf.setFillColor(...PDF_THEME.white);
    }
    pdf.rect(x, currentY, totalWidth, rowHeight, 'F');

    // Subtle row border
    pdf.setDrawColor(...PDF_THEME.border);
    pdf.setLineWidth(0.2);
    pdf.line(x, currentY, x + totalWidth, currentY);

    cellLines.forEach((lines, index) => {
      const colX = x + colWidths.slice(0, index).reduce((sum, w) => sum + w, 0);
      pdf.setTextColor(...PDF_THEME.dark);
      pdf.text(lines, colX + rowPadding + 1, currentY + rowPadding + lineHeight - 1);
    });

    currentY += rowHeight;
  });

  // Bottom border
  pdf.setDrawColor(...PDF_THEME.borderDark);
  pdf.setLineWidth(0.5);
  pdf.line(x, currentY, x + totalWidth, currentY);
  pdf.setTextColor(0, 0, 0);

  return currentY;
};

/**
 * Capture a screenshot of the Cesium viewer
 * @param {Object} viewer - The Cesium viewer instance
 * @param {number} width - Screenshot width
 * @param {number} height - Screenshot height
 * @returns {Promise<string>} - Base64 encoded image
 */
const captureMapScreenshot = async (
  viewer,
  width = 900,
  height = 520,
  options = {}
) => {
  const {
    quality = 0.72,
    preferJpeg = true,
    maxScale = 1.15,
  } = options;

  if (!viewer || viewer.isDestroyed()) {
    throw new Error('Viewer is not available');
  }

  if (!viewer.scene || !viewer.scene.canvas) {
    throw new Error('Viewer canvas is not available');
  }

  const canvas = viewer.scene.canvas;

  if (canvas.width === 0 || canvas.height === 0) {
    throw new Error('Canvas has zero dimensions');
  }

  if (!canvas.toDataURL) {
    throw new Error('Canvas does not support toDataURL');
  }

  const tryCapture = () => {
    let dataURL = null;

    const exportCanvas = document.createElement('canvas');
    const scale = Math.min(width / canvas.width, height / canvas.height, 1);
    exportCanvas.width = Math.max(1, Math.round(canvas.width * scale));
    exportCanvas.height = Math.max(1, Math.round(canvas.height * scale));

    const ctx = exportCanvas.getContext('2d');
    if (!ctx) {
      throw new Error('Unable to allocate canvas context');
    }

    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    ctx.drawImage(canvas, 0, 0, exportCanvas.width, exportCanvas.height);

    if (preferJpeg) {
      dataURL = exportCanvas.toDataURL('image/jpeg', quality);
    } else {
      dataURL = exportCanvas.toDataURL('image/png', 0.9);
    }

    if (dataURL && dataURL.length > 100 && dataURL.startsWith('data:image')) {
      return dataURL;
    }

    return null;
  };

  const originalResolutionScale = viewer.resolutionScale;
  const originalUseBrowserResolution = viewer.useBrowserRecommendedResolution;

  try {
    const targetScale = Math.min(window.devicePixelRatio || 1, maxScale);
    viewer.useBrowserRecommendedResolution = false;
    viewer.resolutionScale = Math.max(targetScale, 1.0);

    viewer.scene.requestRender();
    await waitForTilesLoaded(viewer.scene, 5000);

    const dataURL = await new Promise((resolve, reject) => {
      const scene = viewer.scene;
      let settled = false;
      let removePostRender = null;

      const timeoutId = setTimeout(() => {
        if (settled) return;
        settled = true;
        if (removePostRender) removePostRender();
        reject(new Error('Timed out waiting for scene render'));
      }, 2000);

      removePostRender = scene.postRender.addEventListener(() => {
        if (settled) return;
        settled = true;
        clearTimeout(timeoutId);
        if (removePostRender) removePostRender();

        try {
          let captured = null;
          try {
            captured = tryCapture();
          } catch (captureError) {
            console.warn('Downscale capture failed:', captureError.message);
          }
          if (captured) {
            resolve(captured);
            return;
          }
          try {
            const fallback = canvas.toDataURL('image/jpeg', quality);
            if (fallback && fallback.length > 100 && fallback.startsWith('data:image')) {
              resolve(fallback);
              return;
            }
          } catch (fallbackError) {
            console.warn('Fallback JPEG export failed:', fallbackError.message);
          }
          reject(new Error('Canvas capture returned empty image'));
        } catch (error) {
          reject(error);
        }
      });

      scene.requestRender();
    });

    return dataURL;
  } catch (error) {
    console.warn('Canvas capture failed:', error?.message || error);

    // Final fallback: create a placeholder image
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = width;
    tempCanvas.height = height;
    const ctx = tempCanvas.getContext('2d');

    if (ctx) {
      ctx.fillStyle = '#f0f0f0';
      ctx.fillRect(0, 0, width, height);
      ctx.fillStyle = '#666';
      ctx.font = '16px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('Map View', width / 2, height / 2);

      const placeholderURL = tempCanvas.toDataURL('image/png');
      console.warn('Using placeholder image due to capture failure');
      return placeholderURL;
    }

    throw error;
  } finally {
    viewer.useBrowserRecommendedResolution = originalUseBrowserResolution;
    viewer.resolutionScale = originalResolutionScale;
    viewer.scene.requestRender();
  }
};

/**
 * Generate parcel boundary coordinates for display
 * @param {Object} feature - The feature object with geometry
 * @returns {string} - Formatted coordinates string
 */
const generateCoordinatesText = (feature) => {
  if (!feature || !feature.geometry) {
    return 'N/A';
  }

  const geometry = feature.geometry;
  let coordinates = [];

  if (geometry.type === 'Polygon' && geometry.coordinates && geometry.coordinates[0]) {
    coordinates = geometry.coordinates[0];
  } else if (geometry.type === 'MultiPolygon' && geometry.coordinates && geometry.coordinates[0] && geometry.coordinates[0][0]) {
    coordinates = geometry.coordinates[0][0];
  }

  if (coordinates.length === 0) {
    return 'N/A';
  }

  // Show first few coordinates
  const coordText = coordinates.slice(0, 5).map(coord => 
    `(${coord[0].toFixed(6)}, ${coord[1].toFixed(6)})`
  ).join(', ');

  if (coordinates.length > 5) {
    return coordText + ` ... (${coordinates.length} total points)`;
  }

  return coordText;
};

/**
 * Draw a beautiful cover page
 */
const drawCoverPage = (pdf, feature) => {
  const pageWidth = pdf.internal.pageSize.getWidth();
  const pageHeight = pdf.internal.pageSize.getHeight();
  const title = feature.properties?.street_name || feature.properties?.full_address || 'Parcel Report';
  const currentDate = new Date().toLocaleDateString('en-CA', {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  });

  // Elegant gradient background (simulated with rectangles)
  pdf.setFillColor(...PDF_THEME.primary);
  pdf.rect(0, 0, pageWidth, 80, 'F');

  pdf.setFillColor(...PDF_THEME.primaryLight);
  pdf.rect(0, 80, pageWidth, 40, 'F');

  // Decorative circles
  pdf.setFillColor(255, 255, 255);
  pdf.setGState(new pdf.GState({ opacity: 0.1 }));
  pdf.circle(pageWidth - 30, 30, 40, 'F');
  pdf.circle(20, 100, 25, 'F');
  pdf.setGState(new pdf.GState({ opacity: 1 }));

  // Logo/Brand area
  pdf.setFillColor(...PDF_THEME.white);
  pdf.setFontSize(24);
  pdf.setFont(undefined, 'bold');
  pdf.text('PROPERTY', 20, 35);
  pdf.setFontSize(20);
  pdf.setFont(undefined, 'normal');
  pdf.text('REPORT', 20, 48);

  // Main title card
  const titleCardY = 140;
  drawCard(pdf, 20, titleCardY, pageWidth - 40, 70, PDF_THEME.white, PDF_THEME.border);

  // Report title
  pdf.setFontSize(22);
  pdf.setFont(undefined, 'bold');
  pdf.setTextColor(...PDF_THEME.dark);
  const titleLines = pdf.splitTextToSize(title, pageWidth - 60);
  pdf.text(titleLines, 30, titleCardY + 20);

  // Metadata
  pdf.setFontSize(11);
  pdf.setFont(undefined, 'normal');
  pdf.setTextColor(...PDF_THEME.muted);

  const metadataY = titleCardY + 20 + (titleLines.length * 10) + 10;

  // Date badge
  pdf.setFillColor(...PDF_THEME.accentLight);
  pdf.roundedRect(30, metadataY - 6, 90, 10, 2, 2, 'F');
  pdf.setFontSize(9);
  pdf.setTextColor(...PDF_THEME.accentDark);
  pdf.setFont(undefined, 'bold');
  pdf.text('GENERATED', 33, metadataY);
  pdf.setFont(undefined, 'normal');
  pdf.text(currentDate, 57, metadataY);

  // Parcel ID if available
  const parcelId = feature.properties?.arn || feature.properties?.pin || feature.properties?.parcel_id;
  if (parcelId) {
    pdf.setFillColor(...PDF_THEME.primaryLight);
    pdf.roundedRect(30, metadataY + 8, 90, 10, 2, 2, 'F');
    pdf.setTextColor(...PDF_THEME.primaryDark);
    pdf.setFont(undefined, 'bold');
    pdf.text('PARCEL ID', 33, metadataY + 14);
    pdf.setFont(undefined, 'normal');
    pdf.text(String(parcelId), 57, metadataY + 14);
  }

  // Footer
  pdf.setFontSize(8);
  pdf.setTextColor(...PDF_THEME.muted);
  pdf.setFont(undefined, 'italic');
  const footerText = 'Real Estate 3D Platform - Comprehensive Property Analysis';
  const footerWidth = pdf.getTextWidth(footerText);
  pdf.text(footerText, (pageWidth - footerWidth) / 2, pageHeight - 30);

  pdf.setTextColor(0, 0, 0);
  pdf.setFont(undefined, 'normal');
};

/**
 * Generate PDF report for parcel data
 * @param {Object} feature - The selected feature
 * @param {Object} viewer - The Cesium viewer instance for screenshots
 * @param {Array} enabledLayers - List of currently enabled layers
 * @returns {Promise<void>}
 */
export const generateParcelPDFReport = async (feature, viewer, _enabledLayers = []) => {
  try {
    const pdf = new jsPDF({ unit: 'mm', format: 'a4', compress: true });
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    const margin = 20;
    const usableWidth = pageWidth - (2 * margin);

    const title = feature.properties?.street_name || feature.properties?.full_address || 'Parcel Report';

    // Draw cover page
    drawCoverPage(pdf, feature);

    // Start content on new page
    pdf.addPage();
    let yPosition = 25;
    let pageNumber = 2;

    // Add header to first content page
    drawPageHeader(pdf, pageNumber, 0, title);
    drawPageFooter(pdf);

    const allLayers = await fetchGeoServerLayers();
    const layerIntersections = await fetchLayerIntersections(feature?.geometry, allLayers);

    // Executive Summary Card
    yPosition = ensureSpace(pdf, yPosition, 50, margin);
    drawSectionHeader(pdf, 'Executive Summary', margin, yPosition, usableWidth);
    yPosition += 8;

    const summaryCardHeight = 35;
    drawCard(pdf, margin, yPosition, usableWidth, summaryCardHeight, PDF_THEME.white, PDF_THEME.border);

    // Centroid with icon
    const centroid = calculateCentroid(feature?.coordinates);
    pdf.setFontSize(9);
    pdf.setFont(undefined, 'bold');
    pdf.setTextColor(...PDF_THEME.darkMuted);
    pdf.text('COORDINATES', margin + 5, yPosition + 8);
    pdf.setFontSize(10);
    pdf.setFont(undefined, 'normal');
    pdf.setTextColor(...PDF_THEME.dark);
    pdf.text(formatCentroid(centroid), margin + 5, yPosition + 15);

    // Area if available
    const areaSqM = feature.properties?.area_sq_m;
    if (areaSqM) {
      pdf.setFontSize(9);
      pdf.setFont(undefined, 'bold');
      pdf.setTextColor(...PDF_THEME.darkMuted);
      pdf.text('AREA', margin + usableWidth / 2, yPosition + 8);
      pdf.setFontSize(10);
      pdf.setFont(undefined, 'normal');
      pdf.setTextColor(...PDF_THEME.dark);
      pdf.text(`${parseFloat(areaSqM).toLocaleString()} m²`, margin + usableWidth / 2, yPosition + 15);
    }

    // Parcel status badge
    pdf.setFontSize(9);
    pdf.setFont(undefined, 'bold');
    pdf.setTextColor(...PDF_THEME.darkMuted);
    pdf.text('STATUS', margin + 5, yPosition + 23);
    pdf.setFontSize(9);
    pdf.setFillColor(...PDF_THEME.success);
    pdf.roundedRect(margin + 5, yPosition + 26, 25, 6, 1, 1, 'F');
    pdf.setTextColor(255, 255, 255);
    pdf.setFont(undefined, 'bold');
    pdf.text('ACTIVE', margin + 8, yPosition + 30);

    pdf.setTextColor(0, 0, 0);
    yPosition += summaryCardHeight + 15;

    // Map Screenshot Section
    yPosition = ensureSpace(pdf, yPosition, 18, margin);
    drawSectionHeader(pdf, 'Location Map', margin, yPosition, usableWidth);
    yPosition += 10;

    try {
      // Capture exactly what the user currently sees
      const mapScreenshot = await captureMapScreenshot(viewer, 900, 520, {
        quality: 0.72,
        preferJpeg: true,
        maxScale: 1.15,
      });

      // Map image with decorative frame
      const imgWidth = usableWidth;
      const imgHeight = imgWidth * 0.58;

      // Map container with shadow
      pdf.setGState(new pdf.GState({ opacity: 0.1 }));
      pdf.setFillColor(0, 0, 0);
      pdf.roundedRect(margin + 2, yPosition + 2, imgWidth, imgHeight, 2, 2, 'F');
      pdf.setGState(new pdf.GState({ opacity: 1 }));

      // White border frame
      pdf.setFillColor(...PDF_THEME.white);
      pdf.roundedRect(margin, yPosition, imgWidth, imgHeight, 2, 2, 'F');

      // Map image
      const imageFormat = mapScreenshot.includes('data:image/png') ? 'PNG' : 'JPEG';
      const imgPadding = 3;
      pdf.addImage(
        mapScreenshot,
        imageFormat,
        margin + imgPadding,
        yPosition + imgPadding,
        imgWidth - imgPadding * 2,
        imgHeight - imgPadding * 2
      );

      // Decorative border
      pdf.setDrawColor(...PDF_THEME.primary);
      pdf.setLineWidth(0.8);
      pdf.roundedRect(margin, yPosition, imgWidth, imgHeight, 2, 2, 'S');

      // Map caption
      pdf.setFontSize(8);
      pdf.setFont(undefined, 'italic');
      pdf.setTextColor(...PDF_THEME.muted);
      pdf.text('Current map view with parcel boundaries', margin, yPosition + imgHeight + 5);
      pdf.setTextColor(0, 0, 0);
      pdf.setFont(undefined, 'normal');

      yPosition += imgHeight + 15;
    } catch (mapError) {
      console.warn('Could not capture map screenshots:', mapError);

      // Error card
      pdf.setFillColor(...PDF_THEME.accentLight);
      pdf.roundedRect(margin, yPosition, usableWidth, 20, 2, 2, 'F');
      pdf.setFontSize(10);
      pdf.setTextColor(...PDF_THEME.accentDark);
      pdf.text('⚠ Map screenshot could not be captured', margin + 5, yPosition + 12);
      pdf.setTextColor(0, 0, 0);
      yPosition += 25;
    }

    // Check if we need a new page
    if (yPosition > 210) {
      pdf.addPage();
      pageNumber++;
      yPosition = 25;
      drawPageHeader(pdf, pageNumber, 0, title);
      drawPageFooter(pdf);
    }
    
    // Property Information Section
    yPosition = ensureSpace(pdf, yPosition, 16, margin);
    drawSectionHeader(pdf, 'Property Details', margin, yPosition, usableWidth);
    yPosition += 10;

    // Boundary coordinates in an info card
    const coordinatesText = generateCoordinatesText(feature);
    yPosition = ensureSpace(pdf, yPosition, 14, margin);

    // Info card for coordinates
    const coordCardHeight = 18;
    pdf.setFillColor(...PDF_THEME.accentLight);
    pdf.roundedRect(margin, yPosition, usableWidth, coordCardHeight, 2, 2, 'F');

    pdf.setFontSize(9);
    pdf.setFont(undefined, 'bold');
    pdf.setTextColor(...PDF_THEME.accentDark);
    pdf.text('BOUNDARY COORDINATES', margin + 4, yPosition + 6);

    pdf.setFontSize(9);
    pdf.setFont(undefined, 'normal');
    pdf.setTextColor(...PDF_THEME.dark);
    const coordLines = pdf.splitTextToSize(coordinatesText, usableWidth - 10);
    pdf.text(coordLines, margin + 4, yPosition + 12);

    pdf.setTextColor(0, 0, 0);
    yPosition += coordCardHeight + 10;
    
    // Group properties by category
    const properties = feature.properties || {};
    const groups = {
      'Parcel Information': {},
      'Address Information': {},
      'Zoning Information': {},
      'Land Use Information': {},
      'Other Information': {}
    };
    
    // Categorize properties
    Object.entries(properties).forEach(([key, value]) => {
      if (key.startsWith('_')) return; // Skip metadata
      
      const lowerKey = key.toLowerCase();
      if (['arn', 'pin', 'parcel_id', 'roll_number', 'plan_number', 'legal_description', 'mpac_code', 'area_sq_m'].some(k => lowerKey.includes(k))) {
        groups['Parcel Information'][key] = value;
      } else if (['street', 'address', 'municipality', 'postal', 'unit'].some(k => lowerKey.includes(k))) {
        groups['Address Information'][key] = value;
      } else if (['zone', 'zoning', 'bylaw', 'permit'].some(k => lowerKey.includes(k))) {
        groups['Zoning Information'][key] = value;
      } else if (['land_use', 'designation', 'amendment', 'official'].some(k => lowerKey.includes(k))) {
        groups['Land Use Information'][key] = value;
      } else {
        groups['Other Information'][key] = value;
      }
    });
    
    // Render each group
    Object.entries(groups).forEach(([groupName, groupProps]) => {
      const entries = Object.entries(groupProps).filter(([key, value]) =>
        value !== null && value !== undefined && value !== ''
      );

      if (entries.length === 0) return;

      // Check if we need a new page before starting a new group
      if (yPosition > 220) {
        pdf.addPage();
        pageNumber++;
        yPosition = 25;
        drawPageHeader(pdf, pageNumber, 0, title);
        drawPageFooter(pdf);
      }

      // Group header with sub-section styling
      yPosition = ensureSpace(pdf, yPosition, 14, margin);

      // Sub-section background
      pdf.setFillColor(...PDF_THEME.light);
      pdf.roundedRect(margin, yPosition - 8, usableWidth, 10, 1.5, 1.5, 'F');

      // Accent line
      pdf.setFillColor(...PDF_THEME.accent);
      pdf.roundedRect(margin, yPosition - 8, 2.5, 10, 1.5, 1.5, 'F');

      pdf.setFontSize(11);
      pdf.setFont(undefined, 'bold');
      pdf.setTextColor(...PDF_THEME.accentDark);
      pdf.text(groupName, margin + 6, yPosition - 2);
      pdf.setTextColor(0, 0, 0);
      yPosition += 7;

      const tableRows = entries.map(([key, value]) => ([
        formatFieldName(key),
        formatFieldValue(value, key),
      ]));

      yPosition = drawStripedTable({
        pdf,
        x: margin,
        y: yPosition,
        headers: ['Attribute', 'Value'],
        rows: tableRows,
        colWidths: [usableWidth * 0.38, usableWidth * 0.62],
        margin,
        headerColor: PDF_THEME.tableHeader,
        stripeColor: PDF_THEME.tableStripe,
      });

      yPosition += 12;
    });
    


    // Add a disclaimer/footer section
    yPosition = ensureSpace(pdf, yPosition, 35, margin);

    // Check if we need a new page
    if (yPosition > 240) {
      pdf.addPage();
      pageNumber++;
      yPosition = 25;
      drawPageHeader(pdf, pageNumber, 0, title);
      drawPageFooter(pdf);
    }

    // Disclaimer card
    pdf.setFillColor(...PDF_THEME.light);
    pdf.roundedRect(margin, yPosition, usableWidth, 28, 2, 2, 'F');

    pdf.setFontSize(8);
    pdf.setFont(undefined, 'bold');
    pdf.setTextColor(...PDF_THEME.darkMuted);
    pdf.text('DISCLAIMER', margin + 4, yPosition + 6);

    pdf.setFontSize(7);
    pdf.setFont(undefined, 'normal');
    pdf.setTextColor(...PDF_THEME.muted);
    const disclaimerText = 'This report is generated for informational purposes only. The data presented is sourced from ' +
      'municipal databases and may not reflect the most current information. Property details should be ' +
      'verified with official sources before making any legal or financial decisions. The Real Estate 3D ' +
      'Platform assumes no liability for decisions made based on this report.';
    const disclaimerLines = pdf.splitTextToSize(disclaimerText, usableWidth - 10);
    pdf.text(disclaimerLines, margin + 4, yPosition + 12);

    pdf.setTextColor(0, 0, 0);
    pdf.setFont(undefined, 'normal');

    // Add total page numbers to all pages
    const totalPages = pdf.internal.getNumberOfPages();
    for (let i = 1; i <= totalPages; i++) {
      pdf.setPage(i);
      if (i > 1) { // Skip cover page
        pdf.setFontSize(8);
        pdf.setTextColor(...PDF_THEME.darkMuted);
        pdf.text(`of ${totalPages}`, pageWidth - margin - 7, 10);
        pdf.setTextColor(0, 0, 0);
      }
    }

    // Save the PDF
    const timestamp = new Date().toISOString().split('T')[0];
    const parcelIdentifier = feature.properties?.arn || feature.properties?.pin || feature.properties?.parcel_id || 'Unknown';
    const filename = `Property_Report_${String(parcelIdentifier).replace(/[^a-zA-Z0-9]/g, '_')}_${timestamp}.pdf`;
    pdf.save(filename);

  } catch (error) {
    console.error('Error generating PDF report:', error);
    alert('Error generating PDF report. Please try again.');
  }
};
